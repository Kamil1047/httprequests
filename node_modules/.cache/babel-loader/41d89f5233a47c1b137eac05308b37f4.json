{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = rewriteLiveReferences;\n\nvar _assert = require(\"assert\");\n\nvar _t = require(\"@babel/types\");\n\nvar _template = require(\"@babel/template\");\n\nvar _helperSimpleAccess = require(\"@babel/helper-simple-access\");\n\nconst {\n  assignmentExpression,\n  callExpression,\n  cloneNode,\n  expressionStatement,\n  getOuterBindingIdentifiers,\n  identifier,\n  isMemberExpression,\n  isVariableDeclaration,\n  jsxIdentifier,\n  jsxMemberExpression,\n  memberExpression,\n  numericLiteral,\n  sequenceExpression,\n  stringLiteral,\n  variableDeclaration,\n  variableDeclarator\n} = _t;\n\nfunction rewriteLiveReferences(programPath, metadata) {\n  const imported = new Map();\n  const exported = new Map();\n\n  const requeueInParent = path => {\n    programPath.requeue(path);\n  };\n\n  for (const [source, data] of metadata.source) {\n    for (const [localName, importName] of data.imports) {\n      imported.set(localName, [source, importName, null]);\n    }\n\n    for (const localName of data.importsNamespace) {\n      imported.set(localName, [source, null, localName]);\n    }\n  }\n\n  for (const [local, data] of metadata.local) {\n    let exportMeta = exported.get(local);\n\n    if (!exportMeta) {\n      exportMeta = [];\n      exported.set(local, exportMeta);\n    }\n\n    exportMeta.push(...data.names);\n  }\n\n  const rewriteBindingInitVisitorState = {\n    metadata,\n    requeueInParent,\n    scope: programPath.scope,\n    exported\n  };\n  programPath.traverse(rewriteBindingInitVisitor, rewriteBindingInitVisitorState);\n  (0, _helperSimpleAccess.default)(programPath, new Set([...Array.from(imported.keys()), ...Array.from(exported.keys())]));\n  const rewriteReferencesVisitorState = {\n    seen: new WeakSet(),\n    metadata,\n    requeueInParent,\n    scope: programPath.scope,\n    imported,\n    exported,\n    buildImportReference: ([source, importName, localName], identNode) => {\n      const meta = metadata.source.get(source);\n\n      if (localName) {\n        if (meta.lazy) identNode = callExpression(identNode, []);\n        return identNode;\n      }\n\n      let namespace = identifier(meta.name);\n      if (meta.lazy) namespace = callExpression(namespace, []);\n\n      if (importName === \"default\" && meta.interop === \"node-default\") {\n        return namespace;\n      }\n\n      const computed = metadata.stringSpecifiers.has(importName);\n      return memberExpression(namespace, computed ? stringLiteral(importName) : identifier(importName), computed);\n    }\n  };\n  programPath.traverse(rewriteReferencesVisitor, rewriteReferencesVisitorState);\n}\n\nconst rewriteBindingInitVisitor = {\n  Scope(path) {\n    path.skip();\n  },\n\n  ClassDeclaration(path) {\n    const {\n      requeueInParent,\n      exported,\n      metadata\n    } = this;\n    const {\n      id\n    } = path.node;\n    if (!id) throw new Error(\"Expected class to have a name\");\n    const localName = id.name;\n    const exportNames = exported.get(localName) || [];\n\n    if (exportNames.length > 0) {\n      const statement = expressionStatement(buildBindingExportAssignmentExpression(metadata, exportNames, identifier(localName)));\n      statement._blockHoist = path.node._blockHoist;\n      requeueInParent(path.insertAfter(statement)[0]);\n    }\n  },\n\n  VariableDeclaration(path) {\n    const {\n      requeueInParent,\n      exported,\n      metadata\n    } = this;\n    Object.keys(path.getOuterBindingIdentifiers()).forEach(localName => {\n      const exportNames = exported.get(localName) || [];\n\n      if (exportNames.length > 0) {\n        const statement = expressionStatement(buildBindingExportAssignmentExpression(metadata, exportNames, identifier(localName)));\n        statement._blockHoist = path.node._blockHoist;\n        requeueInParent(path.insertAfter(statement)[0]);\n      }\n    });\n  }\n\n};\n\nconst buildBindingExportAssignmentExpression = (metadata, exportNames, localExpr) => {\n  return (exportNames || []).reduce((expr, exportName) => {\n    const {\n      stringSpecifiers\n    } = metadata;\n    const computed = stringSpecifiers.has(exportName);\n    return assignmentExpression(\"=\", memberExpression(identifier(metadata.exportName), computed ? stringLiteral(exportName) : identifier(exportName), computed), expr);\n  }, localExpr);\n};\n\nconst buildImportThrow = localName => {\n  return _template.default.expression.ast`\n    (function() {\n      throw new Error('\"' + '${localName}' + '\" is read-only.');\n    })()\n  `;\n};\n\nconst rewriteReferencesVisitor = {\n  ReferencedIdentifier(path) {\n    const {\n      seen,\n      buildImportReference,\n      scope,\n      imported,\n      requeueInParent\n    } = this;\n    if (seen.has(path.node)) return;\n    seen.add(path.node);\n    const localName = path.node.name;\n    const importData = imported.get(localName);\n\n    if (importData) {\n      const localBinding = path.scope.getBinding(localName);\n      const rootBinding = scope.getBinding(localName);\n      if (rootBinding !== localBinding) return;\n      const ref = buildImportReference(importData, path.node);\n      ref.loc = path.node.loc;\n\n      if ((path.parentPath.isCallExpression({\n        callee: path.node\n      }) || path.parentPath.isOptionalCallExpression({\n        callee: path.node\n      }) || path.parentPath.isTaggedTemplateExpression({\n        tag: path.node\n      })) && isMemberExpression(ref)) {\n        path.replaceWith(sequenceExpression([numericLiteral(0), ref]));\n      } else if (path.isJSXIdentifier() && isMemberExpression(ref)) {\n        const {\n          object,\n          property\n        } = ref;\n        path.replaceWith(jsxMemberExpression(jsxIdentifier(object.name), jsxIdentifier(property.name)));\n      } else {\n        path.replaceWith(ref);\n      }\n\n      requeueInParent(path);\n      path.skip();\n    }\n  },\n\n  AssignmentExpression: {\n    exit(path) {\n      const {\n        scope,\n        seen,\n        imported,\n        exported,\n        requeueInParent,\n        buildImportReference\n      } = this;\n      if (seen.has(path.node)) return;\n      seen.add(path.node);\n      const left = path.get(\"left\");\n      if (left.isMemberExpression()) return;\n\n      if (left.isIdentifier()) {\n        const localName = left.node.name;\n\n        if (scope.getBinding(localName) !== path.scope.getBinding(localName)) {\n          return;\n        }\n\n        const exportedNames = exported.get(localName);\n        const importData = imported.get(localName);\n\n        if ((exportedNames == null ? void 0 : exportedNames.length) > 0 || importData) {\n          _assert(path.node.operator === \"=\", \"Path was not simplified\");\n\n          const assignment = path.node;\n\n          if (importData) {\n            assignment.left = buildImportReference(importData, assignment.left);\n            assignment.right = sequenceExpression([assignment.right, buildImportThrow(localName)]);\n          }\n\n          path.replaceWith(buildBindingExportAssignmentExpression(this.metadata, exportedNames, assignment));\n          requeueInParent(path);\n        }\n      } else {\n        const ids = left.getOuterBindingIdentifiers();\n        const programScopeIds = Object.keys(ids).filter(localName => scope.getBinding(localName) === path.scope.getBinding(localName));\n        const id = programScopeIds.find(localName => imported.has(localName));\n\n        if (id) {\n          path.node.right = sequenceExpression([path.node.right, buildImportThrow(id)]);\n        }\n\n        const items = [];\n        programScopeIds.forEach(localName => {\n          const exportedNames = exported.get(localName) || [];\n\n          if (exportedNames.length > 0) {\n            items.push(buildBindingExportAssignmentExpression(this.metadata, exportedNames, identifier(localName)));\n          }\n        });\n\n        if (items.length > 0) {\n          let node = sequenceExpression(items);\n\n          if (path.parentPath.isExpressionStatement()) {\n            node = expressionStatement(node);\n            node._blockHoist = path.parentPath.node._blockHoist;\n          }\n\n          const statement = path.insertAfter(node)[0];\n          requeueInParent(statement);\n        }\n      }\n    }\n\n  },\n\n  \"ForOfStatement|ForInStatement\"(path) {\n    const {\n      scope,\n      node\n    } = path;\n    const {\n      left\n    } = node;\n    const {\n      exported,\n      imported,\n      scope: programScope\n    } = this;\n\n    if (!isVariableDeclaration(left)) {\n      let didTransformExport = false,\n          importConstViolationName;\n      const loopBodyScope = path.get(\"body\").scope;\n\n      for (const name of Object.keys(getOuterBindingIdentifiers(left))) {\n        if (programScope.getBinding(name) === scope.getBinding(name)) {\n          if (exported.has(name)) {\n            didTransformExport = true;\n\n            if (loopBodyScope.hasOwnBinding(name)) {\n              loopBodyScope.rename(name);\n            }\n          }\n\n          if (imported.has(name) && !importConstViolationName) {\n            importConstViolationName = name;\n          }\n        }\n      }\n\n      if (!didTransformExport && !importConstViolationName) {\n        return;\n      }\n\n      path.ensureBlock();\n      const bodyPath = path.get(\"body\");\n      const newLoopId = scope.generateUidIdentifierBasedOnNode(left);\n      path.get(\"left\").replaceWith(variableDeclaration(\"let\", [variableDeclarator(cloneNode(newLoopId))]));\n      scope.registerDeclaration(path.get(\"left\"));\n\n      if (didTransformExport) {\n        bodyPath.unshiftContainer(\"body\", expressionStatement(assignmentExpression(\"=\", left, newLoopId)));\n      }\n\n      if (importConstViolationName) {\n        bodyPath.unshiftContainer(\"body\", expressionStatement(buildImportThrow(importConstViolationName)));\n      }\n    }\n  }\n\n};","map":{"version":3,"sources":["/Users/indianic/Desktop/react/section14/httprequests/node_modules/@babel/helper-module-transforms/lib/rewrite-live-references.js"],"names":["Object","defineProperty","exports","value","default","rewriteLiveReferences","_assert","require","_t","_template","_helperSimpleAccess","assignmentExpression","callExpression","cloneNode","expressionStatement","getOuterBindingIdentifiers","identifier","isMemberExpression","isVariableDeclaration","jsxIdentifier","jsxMemberExpression","memberExpression","numericLiteral","sequenceExpression","stringLiteral","variableDeclaration","variableDeclarator","programPath","metadata","imported","Map","exported","requeueInParent","path","requeue","source","data","localName","importName","imports","set","importsNamespace","local","exportMeta","get","push","names","rewriteBindingInitVisitorState","scope","traverse","rewriteBindingInitVisitor","Set","Array","from","keys","rewriteReferencesVisitorState","seen","WeakSet","buildImportReference","identNode","meta","lazy","namespace","name","interop","computed","stringSpecifiers","has","rewriteReferencesVisitor","Scope","skip","ClassDeclaration","id","node","Error","exportNames","length","statement","buildBindingExportAssignmentExpression","_blockHoist","insertAfter","VariableDeclaration","forEach","localExpr","reduce","expr","exportName","buildImportThrow","expression","ast","ReferencedIdentifier","add","importData","localBinding","getBinding","rootBinding","ref","loc","parentPath","isCallExpression","callee","isOptionalCallExpression","isTaggedTemplateExpression","tag","replaceWith","isJSXIdentifier","object","property","AssignmentExpression","exit","left","isIdentifier","exportedNames","operator","assignment","right","ids","programScopeIds","filter","find","items","isExpressionStatement","programScope","didTransformExport","importConstViolationName","loopBodyScope","hasOwnBinding","rename","ensureBlock","bodyPath","newLoopId","generateUidIdentifierBasedOnNode","registerDeclaration","unshiftContainer"],"mappings":"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","sourcesContent":["\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = rewriteLiveReferences;\n\nvar _assert = require(\"assert\");\n\nvar _t = require(\"@babel/types\");\n\nvar _template = require(\"@babel/template\");\n\nvar _helperSimpleAccess = require(\"@babel/helper-simple-access\");\n\nconst {\n  assignmentExpression,\n  callExpression,\n  cloneNode,\n  expressionStatement,\n  getOuterBindingIdentifiers,\n  identifier,\n  isMemberExpression,\n  isVariableDeclaration,\n  jsxIdentifier,\n  jsxMemberExpression,\n  memberExpression,\n  numericLiteral,\n  sequenceExpression,\n  stringLiteral,\n  variableDeclaration,\n  variableDeclarator\n} = _t;\n\nfunction rewriteLiveReferences(programPath, metadata) {\n  const imported = new Map();\n  const exported = new Map();\n\n  const requeueInParent = path => {\n    programPath.requeue(path);\n  };\n\n  for (const [source, data] of metadata.source) {\n    for (const [localName, importName] of data.imports) {\n      imported.set(localName, [source, importName, null]);\n    }\n\n    for (const localName of data.importsNamespace) {\n      imported.set(localName, [source, null, localName]);\n    }\n  }\n\n  for (const [local, data] of metadata.local) {\n    let exportMeta = exported.get(local);\n\n    if (!exportMeta) {\n      exportMeta = [];\n      exported.set(local, exportMeta);\n    }\n\n    exportMeta.push(...data.names);\n  }\n\n  const rewriteBindingInitVisitorState = {\n    metadata,\n    requeueInParent,\n    scope: programPath.scope,\n    exported\n  };\n  programPath.traverse(rewriteBindingInitVisitor, rewriteBindingInitVisitorState);\n  (0, _helperSimpleAccess.default)(programPath, new Set([...Array.from(imported.keys()), ...Array.from(exported.keys())]));\n  const rewriteReferencesVisitorState = {\n    seen: new WeakSet(),\n    metadata,\n    requeueInParent,\n    scope: programPath.scope,\n    imported,\n    exported,\n    buildImportReference: ([source, importName, localName], identNode) => {\n      const meta = metadata.source.get(source);\n\n      if (localName) {\n        if (meta.lazy) identNode = callExpression(identNode, []);\n        return identNode;\n      }\n\n      let namespace = identifier(meta.name);\n      if (meta.lazy) namespace = callExpression(namespace, []);\n\n      if (importName === \"default\" && meta.interop === \"node-default\") {\n        return namespace;\n      }\n\n      const computed = metadata.stringSpecifiers.has(importName);\n      return memberExpression(namespace, computed ? stringLiteral(importName) : identifier(importName), computed);\n    }\n  };\n  programPath.traverse(rewriteReferencesVisitor, rewriteReferencesVisitorState);\n}\n\nconst rewriteBindingInitVisitor = {\n  Scope(path) {\n    path.skip();\n  },\n\n  ClassDeclaration(path) {\n    const {\n      requeueInParent,\n      exported,\n      metadata\n    } = this;\n    const {\n      id\n    } = path.node;\n    if (!id) throw new Error(\"Expected class to have a name\");\n    const localName = id.name;\n    const exportNames = exported.get(localName) || [];\n\n    if (exportNames.length > 0) {\n      const statement = expressionStatement(buildBindingExportAssignmentExpression(metadata, exportNames, identifier(localName)));\n      statement._blockHoist = path.node._blockHoist;\n      requeueInParent(path.insertAfter(statement)[0]);\n    }\n  },\n\n  VariableDeclaration(path) {\n    const {\n      requeueInParent,\n      exported,\n      metadata\n    } = this;\n    Object.keys(path.getOuterBindingIdentifiers()).forEach(localName => {\n      const exportNames = exported.get(localName) || [];\n\n      if (exportNames.length > 0) {\n        const statement = expressionStatement(buildBindingExportAssignmentExpression(metadata, exportNames, identifier(localName)));\n        statement._blockHoist = path.node._blockHoist;\n        requeueInParent(path.insertAfter(statement)[0]);\n      }\n    });\n  }\n\n};\n\nconst buildBindingExportAssignmentExpression = (metadata, exportNames, localExpr) => {\n  return (exportNames || []).reduce((expr, exportName) => {\n    const {\n      stringSpecifiers\n    } = metadata;\n    const computed = stringSpecifiers.has(exportName);\n    return assignmentExpression(\"=\", memberExpression(identifier(metadata.exportName), computed ? stringLiteral(exportName) : identifier(exportName), computed), expr);\n  }, localExpr);\n};\n\nconst buildImportThrow = localName => {\n  return _template.default.expression.ast`\n    (function() {\n      throw new Error('\"' + '${localName}' + '\" is read-only.');\n    })()\n  `;\n};\n\nconst rewriteReferencesVisitor = {\n  ReferencedIdentifier(path) {\n    const {\n      seen,\n      buildImportReference,\n      scope,\n      imported,\n      requeueInParent\n    } = this;\n    if (seen.has(path.node)) return;\n    seen.add(path.node);\n    const localName = path.node.name;\n    const importData = imported.get(localName);\n\n    if (importData) {\n      const localBinding = path.scope.getBinding(localName);\n      const rootBinding = scope.getBinding(localName);\n      if (rootBinding !== localBinding) return;\n      const ref = buildImportReference(importData, path.node);\n      ref.loc = path.node.loc;\n\n      if ((path.parentPath.isCallExpression({\n        callee: path.node\n      }) || path.parentPath.isOptionalCallExpression({\n        callee: path.node\n      }) || path.parentPath.isTaggedTemplateExpression({\n        tag: path.node\n      })) && isMemberExpression(ref)) {\n        path.replaceWith(sequenceExpression([numericLiteral(0), ref]));\n      } else if (path.isJSXIdentifier() && isMemberExpression(ref)) {\n        const {\n          object,\n          property\n        } = ref;\n        path.replaceWith(jsxMemberExpression(jsxIdentifier(object.name), jsxIdentifier(property.name)));\n      } else {\n        path.replaceWith(ref);\n      }\n\n      requeueInParent(path);\n      path.skip();\n    }\n  },\n\n  AssignmentExpression: {\n    exit(path) {\n      const {\n        scope,\n        seen,\n        imported,\n        exported,\n        requeueInParent,\n        buildImportReference\n      } = this;\n      if (seen.has(path.node)) return;\n      seen.add(path.node);\n      const left = path.get(\"left\");\n      if (left.isMemberExpression()) return;\n\n      if (left.isIdentifier()) {\n        const localName = left.node.name;\n\n        if (scope.getBinding(localName) !== path.scope.getBinding(localName)) {\n          return;\n        }\n\n        const exportedNames = exported.get(localName);\n        const importData = imported.get(localName);\n\n        if ((exportedNames == null ? void 0 : exportedNames.length) > 0 || importData) {\n          _assert(path.node.operator === \"=\", \"Path was not simplified\");\n\n          const assignment = path.node;\n\n          if (importData) {\n            assignment.left = buildImportReference(importData, assignment.left);\n            assignment.right = sequenceExpression([assignment.right, buildImportThrow(localName)]);\n          }\n\n          path.replaceWith(buildBindingExportAssignmentExpression(this.metadata, exportedNames, assignment));\n          requeueInParent(path);\n        }\n      } else {\n        const ids = left.getOuterBindingIdentifiers();\n        const programScopeIds = Object.keys(ids).filter(localName => scope.getBinding(localName) === path.scope.getBinding(localName));\n        const id = programScopeIds.find(localName => imported.has(localName));\n\n        if (id) {\n          path.node.right = sequenceExpression([path.node.right, buildImportThrow(id)]);\n        }\n\n        const items = [];\n        programScopeIds.forEach(localName => {\n          const exportedNames = exported.get(localName) || [];\n\n          if (exportedNames.length > 0) {\n            items.push(buildBindingExportAssignmentExpression(this.metadata, exportedNames, identifier(localName)));\n          }\n        });\n\n        if (items.length > 0) {\n          let node = sequenceExpression(items);\n\n          if (path.parentPath.isExpressionStatement()) {\n            node = expressionStatement(node);\n            node._blockHoist = path.parentPath.node._blockHoist;\n          }\n\n          const statement = path.insertAfter(node)[0];\n          requeueInParent(statement);\n        }\n      }\n    }\n\n  },\n\n  \"ForOfStatement|ForInStatement\"(path) {\n    const {\n      scope,\n      node\n    } = path;\n    const {\n      left\n    } = node;\n    const {\n      exported,\n      imported,\n      scope: programScope\n    } = this;\n\n    if (!isVariableDeclaration(left)) {\n      let didTransformExport = false,\n          importConstViolationName;\n      const loopBodyScope = path.get(\"body\").scope;\n\n      for (const name of Object.keys(getOuterBindingIdentifiers(left))) {\n        if (programScope.getBinding(name) === scope.getBinding(name)) {\n          if (exported.has(name)) {\n            didTransformExport = true;\n\n            if (loopBodyScope.hasOwnBinding(name)) {\n              loopBodyScope.rename(name);\n            }\n          }\n\n          if (imported.has(name) && !importConstViolationName) {\n            importConstViolationName = name;\n          }\n        }\n      }\n\n      if (!didTransformExport && !importConstViolationName) {\n        return;\n      }\n\n      path.ensureBlock();\n      const bodyPath = path.get(\"body\");\n      const newLoopId = scope.generateUidIdentifierBasedOnNode(left);\n      path.get(\"left\").replaceWith(variableDeclaration(\"let\", [variableDeclarator(cloneNode(newLoopId))]));\n      scope.registerDeclaration(path.get(\"left\"));\n\n      if (didTransformExport) {\n        bodyPath.unshiftContainer(\"body\", expressionStatement(assignmentExpression(\"=\", left, newLoopId)));\n      }\n\n      if (importConstViolationName) {\n        bodyPath.unshiftContainer(\"body\", expressionStatement(buildImportThrow(importConstViolationName)));\n      }\n    }\n  }\n\n};"]},"metadata":{},"sourceType":"script"}